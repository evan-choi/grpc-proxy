using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Grpc.Core;
using Grpc.Proxy.Tools.Extensions;
using Grpc.Proxy.Tools.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Grpc.Proxy.Tools;

[Generator]
public class GrpcServiceProxyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<ImmutableArray<ServiceBaseDeclaration>> serviceBaseDeclarationsProvier
            = context.SyntaxProvider
                .CreateSyntaxProvider(
                    static (node, _) => node is ClassDeclarationSyntax { AttributeLists.Count: 1 },
                    static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(x => x is not null)
                .Collect();

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(serviceBaseDeclarationsProvier),
            (spc, arg) => Execute(spc, arg.Left, arg.Right)
        );
    }

    private static ServiceBaseDeclaration GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var node = (ClassDeclarationSyntax)context.Node;

        if (!IsBaseService(context, node))
            return null;

        var attributeSyntax = node.AttributeLists[0].Attributes[0];

        if (!BindServiceMethodDataDeclaration.TryResolve(context, attributeSyntax, out var bindServiceMethodData))
            return null;

        if (!GrpcServiceDeclaration.TryResolve(context, bindServiceMethodData.BindType, out var serviceDescriptorDeclaration))
            return null;

        return new ServiceBaseDeclaration(
            context.SemanticModel.GetDeclaredSymbol(node),
            serviceDescriptorDeclaration);
    }

    private static bool IsBaseService(GeneratorSyntaxContext context, ClassDeclarationSyntax node)
    {
        if (!node.Identifier.Text.EndsWith("Base") ||
            !node.Modifiers.Any(SyntaxKind.AbstractKeyword) ||
            node.AttributeLists[0].Attributes.Count != 1)
        {
            return false;
        }

        var attributeSyntax = node.AttributeLists[0].Attributes[0];

        if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
            return false;

        var bindServiceMethodAttributeTypeSymbol = context.SemanticModel.Compilation
            .GetTypeByMetadataName(typeof(BindServiceMethodAttribute).FullName!);

        if (!SymbolEqualityComparer.Default.Equals(attributeSymbol.ContainingType, bindServiceMethodAttributeTypeSymbol))
            return false;

        return true;
    }

    private void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<ServiceBaseDeclaration> declarations)
    {
        foreach (var baseDeclaration in declarations)
        {
            var gen = new StringBuilder();

            var serviceName = baseDeclaration.ServiceDeclaration.ServiceName.Split('.').Last();
            var serviceType = baseDeclaration.ServiceDeclaration.TypeSymbol;
            var serviceTypeSyntax = (ClassDeclarationSyntax)serviceType.GetSyntax();

            var @namespace = GetFullNamespace(serviceType.ContainingNamespace);

            gen.AppendLine("// <auto-generated>");
            gen.AppendLine("//     Generated by the gRPC Proxy.  DO NOT EDIT!");
            gen.AppendLine($"//     service: {baseDeclaration.ServiceDeclaration.ServiceName}");
            gen.AppendLine("// </auto-generated>");
            gen.AppendLine("using grpc = global::Grpc.Core;");
            gen.AppendLine("using grpcProxy = global::Grpc.Proxy;");
            gen.AppendLine();

            if (!string.IsNullOrEmpty(@namespace))
                gen.AppendLine($"namespace {@namespace};");

            gen.Append($@"
{serviceTypeSyntax.Modifiers} class {serviceType.Name}
{{
    public class {serviceName}Proxy : {baseDeclaration.TypeSymbol.Name}
    {{
        private readonly grpcProxy::IProxyCallInvoker _invoker;

        public {serviceName}Proxy(grpcProxy::IProxyCallInvoker callInvoker)
        {{
            _invoker = callInvoker;
        }}
");

            foreach (KeyValuePair<string, GrpcMethodDeclaration> entry in baseDeclaration.ServiceDeclaration.Methods.OrderBy(x => x.Value.Name))
            {
                (string returnType, ParameterInfo[] parameterTypes) = GetMethodLayout(entry.Value);
                var invokerMethodName = $"{entry.Value.Type.ToString()}Call";

                gen.Append($@"
        public override {returnType} {entry.Value.Name}({string.Join(", ", parameterTypes)})
        {{
            return _invoker.{invokerMethodName}({entry.Key}, {string.Join(", ", parameterTypes.Select(x => x.Name))});
        }}
");
            }

            gen.Append(@"
    }
}");

            context.AddSource($"{serviceType.Name}.{serviceName}Proxy.gen.cs", SourceText.From(gen.ToString(), Encoding.UTF8));
        }
    }

    private static string GetFullNamespace(INamespaceSymbol symbol)
    {
        if (symbol is null)
            return null;

        var builder = new StringBuilder();

        do
        {
            if (builder.Length > 0)
                builder.Insert(0, '.');

            builder.Insert(0, symbol.Name);
            symbol = symbol.ContainingNamespace;
        } while (symbol is { Name.Length: > 0 });

        return builder.ToString();
    }

    private static (string ReturnType, ParameterInfo[] ParameterTypes) GetMethodLayout(GrpcMethodDeclaration method)
    {
        var requestType = $"global::{GetFullNamespace(method.Request.ContainingNamespace)}.{method.Request.Name}";
        var responseType = $"global::{GetFullNamespace(method.Response.ContainingNamespace)}.{method.Response.Name}";
        var serverCallContext = new ParameterInfo("grpc::ServerCallContext", "context");

        return method.Type switch
        {
            MethodType.Unary => (
                Task(responseType),
                new[]
                {
                    new ParameterInfo(requestType, "request"),
                    serverCallContext
                }
            ),
            MethodType.ClientStreaming => (
                Task(responseType),
                new[]
                {
                    new ParameterInfo(IAsyncStreamReader(requestType), "requestStream"),
                    serverCallContext
                }
            ),
            MethodType.ServerStreaming => (
                Task(null),
                new[]
                {
                    new ParameterInfo(requestType, "request"),
                    new ParameterInfo(IServerStreamWriter(responseType), "responseStream"),
                    serverCallContext
                }
            ),
            MethodType.DuplexStreaming => (
                Task(null),
                new[]
                {
                    new ParameterInfo(IAsyncStreamReader(requestType), "requestStream"),
                    new ParameterInfo(IServerStreamWriter(responseType), "responseStream"),
                    serverCallContext
                }
            ),
            _ => throw new InvalidOperationException()
        };

        static string Task(string genericType)
        {
            if (genericType is null)
                return "global::System.Threading.Tasks.Task";

            return $"global::System.Threading.Tasks.Task<{genericType}>";
        }

        static string IAsyncStreamReader(string genericType)
        {
            return $"grpc::IAsyncStreamReader<{genericType}>";
        }

        static string IServerStreamWriter(string genericType)
        {
            return $"grpc::IServerStreamWriter<{genericType}>";
        }
    }

    private readonly struct ParameterInfo
    {
        public string Type { get; }

        public string Name { get; }

        public ParameterInfo(string type, string name)
        {
            Type = type;
            Name = name;
        }

        public override string ToString()
        {
            return $"{Type} {Name}";
        }
    }
}
